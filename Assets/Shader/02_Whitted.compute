// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "BasicRay.hlsl"
#include "SceneData.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct ExtraHitInfo
{
    HitInfo hitInfo;
    uint hitMesh;
    uint hitIndexOffset;
    float2 hitUV; // 重心座標，打到的點可以用 (1-u-v) * v0 + u * v1 + v * v2 內插而得
};

ExtraHitInfo Trace(Ray ray, float rayDistance)
{
    HitInfo hitInfo = CreateEmptyHitInfo();
    hitInfo.distance = rayDistance;
    uint hitMesh, hitIndexOffset;
    float2 hitUV = float2(-1, -1);
    
    // 對每個 Mesh 的每個三角面比較
    uint meshCount, stride;
    _MeshObjects.GetDimensions(meshCount, stride);
    for (uint mesh = 0; mesh < meshCount; ++mesh)
    {
        MeshObject MeshObj = _MeshObjects[mesh];
        
        // 對於每個三角面
        for (int offset = MeshObj.indices_offset; offset < MeshObj.indices_offset + MeshObj.indices_count; offset += 3)
        {
            int v0 = _Indices[offset], v1 = _Indices[offset + 1], v2 = _Indices[offset + 2];
            float4 globalV0 = mul(MeshObj.localToWorldMatrix, float4(_Vertices[v0], 1));
            float4 globalV1 = mul(MeshObj.localToWorldMatrix, float4(_Vertices[v1], 1));
            float4 globalV2 = mul(MeshObj.localToWorldMatrix, float4(_Vertices[v2], 1));
            float u = -1, v = -1;
            
            if (IntersectTriangle_MT97(ray, globalV0.xyz, globalV1.xyz, globalV2.xyz, hitInfo, u, v))
            {
                hitMesh = mesh;
                hitIndexOffset = offset;
                hitUV = float2(u, v);
            }
        }
    }

    ExtraHitInfo result;
    result.hitInfo = hitInfo;
    result.hitMesh = hitMesh;
    result.hitIndexOffset = hitIndexOffset;
    result.hitUV = hitUV;
    return result;
}

float3 GetKd(ExtraHitInfo extraHitInfo)
{
    float4 Kd = _MeshObjects[extraHitInfo.hitMesh].Kd;
    
    float3 color = Kd.xyz;
    
    // 計算 texcoord
    uint offset = extraHitInfo.hitIndexOffset;
    int v0 = _Indices[offset], v1 = _Indices[offset + 1], v2 = _Indices[offset + 2];
    float2 hitUV = extraHitInfo.hitUV;
    float2 texcoord = (1 - hitUV.x - hitUV.y) * _UVs[v0] + hitUV.x * _UVs[v1] + hitUV.y * _UVs[v2];
    
    // sample (Note: Sample 不能放在 if 分支內)
    float3 colorFromTexture = _Textures.SampleLevel(sampler_Textures, float3(texcoord, Kd.x), 0).xyz;
    
    // Kd.w == 0 -> color; Kd.w == -1 -> colorFromTexture
    return lerp(color, colorFromTexture, -Kd.w);
}

// Phong Interpolation of Normal
float3 GetNormal(ExtraHitInfo extraHitInfo)
{
    float3x3 rot = _MeshObjects[extraHitInfo.hitMesh].localToWorldMatrix;
    
    uint offset = extraHitInfo.hitIndexOffset;
    int v0 = _Indices[offset], v1 = _Indices[offset + 1], v2 = _Indices[offset + 2];
    float2 hitUV = extraHitInfo.hitUV;
    
    float3 localN = normalize((1.f - hitUV.x - hitUV.y) * normalize(_Normals[v0]) + hitUV.x * normalize(_Normals[v1]) + hitUV.y * normalize(_Normals[v2]));
    float3 N = mul(rot, localN);
    
    if (dot(N, extraHitInfo.hitInfo.normal) < 0)
        return -N;
    else
        return N;
}

float3 Shade(Ray currentRay, ExtraHitInfo extraHitInfo)
{
    float3 color = float3(0, 0, 0);
    uint lightCount, stride;
    _Lights.GetDimensions(lightCount, stride);
    float3 Ks = float3(1, 1, 1);
    
    for (int i = 0; i < 3; ++i)
    {
        // 沒打到任何東西
        if (isinf(extraHitInfo.hitInfo.distance))
            break;
        
        const float3 N = GetNormal(extraHitInfo);
        
        Ray shadowRay;
        shadowRay.origin = extraHitInfo.hitInfo.position + N * 0.001;
        float shadowRayDistance = 1.#INF;
    
        for (uint i = 0; i < lightCount; ++i)
        {
            float4 light = _Lights[i];
        
            // 生成 物體 -> 光源 的 shadow ray
            if (light.w == 0)
            {
                shadowRay.dir = normalize(light.xyz);
                shadowRayDistance = 1.#INF;
            }
            else
            {
                shadowRay.dir = normalize(light.xyz - shadowRay.origin);
                shadowRayDistance = distance(light.xyz, shadowRay.origin);
            }

            ExtraHitInfo shadowHit = Trace(shadowRay, shadowRayDistance);
        
            // 被遮住（有打到東西）
            if (any(shadowHit.hitUV != float2(-1, -1)))
                continue;
        
            // 計算 Phong Shading
            if (dot(N, shadowRay.dir) > 0)
            {
                // Diffuse
                float3 Kd = GetKd(extraHitInfo);
                float NdotL = max(dot(N, shadowRay.dir), 0);
                float3 diffuse = Kd * _LightColors[i] * NdotL;

                color += diffuse * Ks;
            }
        }
        
        // specular ray
        Ks = _MeshObjects[extraHitInfo.hitMesh].Ks;
        if (distance(Ks, float3(0, 0, 0)) > 0.001)
        {
            // 產生 specular ray
            Ray specularRay;
            specularRay.origin = shadowRay.origin; // 物體的位置
            specularRay.dir = reflect(currentRay.dir, N);
            ExtraHitInfo specularHit = Trace(specularRay, 1.#INF);
                
            // 修改目前的 Ray, 繼續迭代
            currentRay = specularRay;
            extraHitInfo = specularHit;
        }
        else
            break;
    }

    return color;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    Ray cameraRay = CreateCameraRay(id.x, id.y);
    ExtraHitInfo extraHitInfo = Trace(cameraRay, 1.#INF);
    Result[id.xy] = float4(Shade(cameraRay, extraHitInfo), 0.0);
}
