// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "BasicRay.hlsl"
#include "SceneData.hlsl"
#include "SceneTrace.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> WorldPosTexture;
RWTexture2D<float4> NormalTexture;

float3 Shade(Ray currentRay, ExtraHitInfo extraHitInfo)
{
    float3 color = float3(0, 0, 0);
    uint lightCount, stride;
    _Lights.GetDimensions(lightCount, stride);
    float3 Ks = float3(1, 1, 1);
    
    // 沒打到任何東西
    if (isinf(extraHitInfo.hitInfo.distance))
        return color;
    
    for (int i = 0; i < 3; ++i)
    {
        const float3 N = GetNormal(extraHitInfo);
        
        Ray shadowRay;
        shadowRay.origin = extraHitInfo.hitInfo.position + N * 0.001;
        float shadowRayDistance = 1.#INF;
    
        for (uint i = 0; i < lightCount; ++i)
        {
            float4 light = _Lights[i];
        
            // 生成 物體 -> 光源 的 shadow ray
            if (light.w == 0)
            {
                shadowRay.dir = normalize(light.xyz);
                shadowRayDistance = 1.#INF;
            }
            else
            {
                shadowRay.dir = normalize(light.xyz - shadowRay.origin);
                shadowRayDistance = distance(light.xyz, shadowRay.origin);
            }

            ExtraHitInfo shadowHit = Trace(shadowRay, shadowRayDistance);
        
            // 被遮住（有打到東西）
            if (any(shadowHit.hitUV != float2(-1, -1)))
                continue;
        
            // 計算 Phong Shading
            if (dot(N, shadowRay.dir) > 0)
            {
                // Diffuse
                float3 Kd = GetKd(extraHitInfo);
                float NdotL = max(dot(N, shadowRay.dir), 0);
                float3 diffuse = Kd * _LightColors[i] * NdotL;

                color += diffuse * Ks;
            }
        }
        
        // specular ray
        Ks = _MeshObjects[extraHitInfo.hitMesh].Ks;
        if (distance(Ks, float3(0, 0, 0)) > 0.001)
        {
            // 產生 specular ray
            Ray specularRay;
            specularRay.origin = shadowRay.origin; // 物體的位置
            specularRay.dir = reflect(currentRay.dir, N);
            ExtraHitInfo specularHit = Trace(specularRay, 1.#INF);
                
            // 修改目前的 Ray, 繼續迭代
            currentRay = specularRay;
            extraHitInfo = specularHit;
        }
        else
            break;
    }

    return color;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    Ray cameraRay = CreateCameraRay(id.x, id.y);
    ExtraHitInfo extraHitInfo = Trace(cameraRay, 1.#INF);
    Result[id.xy] = float4(Shade(cameraRay, extraHitInfo), 0.0);
    WorldPosTexture[id.xy] = float4(extraHitInfo.hitInfo.position, 1);
    NormalTexture[id.xy] = float4(GetNormal(extraHitInfo), 0);
}
