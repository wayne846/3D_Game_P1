// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "BasicRay.hlsl"
#include "SceneData.hlsl"
#include "SceneTrace.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
RWTexture2D<float4> WorldPosTexture;
RWTexture2D<float4> NormalTexture;

float3 Shade(ExtraHitInfo extraHitInfo)
{
    float3 color = float3(0, 0, 0);
    uint lightCount, stride;
    _Lights.GetDimensions(lightCount, stride);
    
    // 沒打到任何東西
    if (isinf(extraHitInfo.hitInfo.distance))
        return color;
    
    const float3 N = GetNormal(extraHitInfo);
    
    Ray shadowRay;
    shadowRay.origin = extraHitInfo.hitInfo.position + N * 0.001;
    float shadowRayDistance = 1.#INF;
    
    for (uint i = 0; i < lightCount; ++i)
    {
        float4 light = _Lights[i];
        
        // 生成 物體 -> 光源 的 shadow ray
        if (light.w == 0)
        {
            shadowRay.dir = normalize(light.xyz);
            shadowRayDistance = 1.#INF;
        }
        else
        {
            shadowRay.dir = normalize(light.xyz - shadowRay.origin);
            shadowRayDistance = distance(light.xyz, shadowRay.origin);
        }

        ExtraHitInfo shadowHit = Trace(shadowRay, shadowRayDistance);
        
        // 被遮住（有打到東西）
        if (any(shadowHit.hitUV != float2(-1, -1)))
            continue;
        
        // 計算 Phong Shading
        if (dot(N, shadowRay.dir) > 0)
        {
            // Diffuse
            float3 Kd = GetKd(extraHitInfo);
            float NdotL = max(dot(N, shadowRay.dir), 0);
            float3 diffuse = Kd * _LightColors[i] * NdotL;

            // Specular
            float3 R = reflect(-shadowRay.dir, N); // 光 -> 物 反射
            float3 V = normalize(mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz - extraHitInfo.hitInfo.position); // 物 -> 眼
            float spec = pow(max(dot(R, V), 0), 100);
            float3 specular = _MeshObjects[extraHitInfo.hitMesh].Ks.xyz * _LightColors[i] * spec;
            
            // Geometry Term
            float G = 1;
            if (light.w == 1) // Point Light
                G = 1 / (shadowRayDistance * shadowRayDistance + 1.0);

            color += (diffuse + specular) * G;
        }
    }

    return color;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Ray cameraRay = CreateCameraRay(id.x, id.y);
    ExtraHitInfo extraHitInfo = Trace(cameraRay, 1.#INF);
    Result[id.xy] = float4(Shade(extraHitInfo), 1.0);
    WorldPosTexture[id.xy] = float4(extraHitInfo.hitInfo.position, 1);
    NormalTexture[id.xy] = float4(extraHitInfo.hitInfo.normal, 0);
}
