// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "BasicRay.hlsl"
#include "SceneData.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

struct ExtraHitInfo
{
    HitInfo hitInfo;
    uint hitMesh;
    uint hitIndexOffset;
    float2 hitUV; // 重心座標，打到的點可以用 (1-u-v) * v0 + u * v1 + v * v2 內插而得
};

ExtraHitInfo Trace(Ray ray, float rayDistance)
{
    HitInfo hitInfo = CreateEmptyHitInfo();
    hitInfo.distance = rayDistance;
    uint hitMesh, hitIndexOffset;
    float2 hitUV = float2(-1, -1);
    
    // 對每個 Mesh 的每個三角面比較
    uint meshCount, stride;
    _MeshObjects.GetDimensions(meshCount, stride);
    for (uint mesh = 0; mesh < meshCount; ++mesh)
    {
        MeshObject MeshObj = _MeshObjects[mesh];
        
        // 對於每個三角面
        for (int offset = MeshObj.indices_offset; offset < MeshObj.indices_offset + MeshObj.indices_count; offset += 3)
        {
            int v0 = _Indices[offset], v1 = _Indices[offset + 1], v2 = _Indices[offset + 2];
            float4 globalV0 = mul(MeshObj.localToWorldMatrix, float4(_Vertices[v0], 1));
            float4 globalV1 = mul(MeshObj.localToWorldMatrix, float4(_Vertices[v1], 1));
            float4 globalV2 = mul(MeshObj.localToWorldMatrix, float4(_Vertices[v2], 1));
            float u = -1, v = -1;
            
            if (IntersectTriangle_MT97(ray, globalV0.xyz, globalV1.xyz, globalV2.xyz, hitInfo, u, v))
            {
                hitMesh = mesh;
                hitIndexOffset = offset;
                hitUV = float2(u, v);
            }
        }
    }

    ExtraHitInfo result;
    result.hitInfo = hitInfo;
    result.hitMesh = hitMesh;
    result.hitIndexOffset = hitIndexOffset;
    result.hitUV = hitUV;
    return result;
}

float3 GetKd(ExtraHitInfo extraHitInfo)
{
    float4 Kd = _MeshObjects[extraHitInfo.hitMesh].Kd;
    
    float3 color = Kd.xyz;
    
    // 計算 texcoord
    uint offset = extraHitInfo.hitIndexOffset;
    int v0 = _Indices[0], v1 = _Indices[1], v2 = _Indices[2];
    float2 hitUV = extraHitInfo.hitUV;
    float2 texcoord = (1 - hitUV.x - hitUV.y) * _UVs[v0] + hitUV.x * _UVs[v1] + hitUV.y * _UVs[v2];
    
    // sample (Note: Sample 不能放在 if 分支內)
    float3 colorFromTexture = _Textures.SampleLevel(sampler_Textures, float3(texcoord, Kd.x), 0).xyz;
    
    // Kd.w == 0 -> color; Kd.w == -1 -> colorFromTexture
    return lerp(color, colorFromTexture, -Kd.w);
}

float3 Shade(ExtraHitInfo extraHitInfo)
{
    float3 color = float3(0, 0, 0);
    uint lightCount, stride;
    _Lights.GetDimensions(lightCount, stride);
    
    Ray shadowRay;
    shadowRay.origin = extraHitInfo.hitInfo.position + extraHitInfo.hitInfo.normal * 0.001;
    float shadowRayDistance = 1.#INF;
    
    for (uint i = 0; i < lightCount; ++i)
    {
        float4 light = _Lights[i];
        
        // 生成 物體 -> 光源 的 shadow ray
        if (light.w == 0)
        {
            shadowRay.dir = normalize(-light.xyz);
            shadowRayDistance = 1.#INF;
        }
        else
        {
            shadowRay.dir = normalize(light.xyz - shadowRay.origin);
            shadowRayDistance = distance(light.xyz, shadowRay.origin);
        }

        ExtraHitInfo shadowHit = Trace(shadowRay, shadowRayDistance);
        
        // 被遮住（有打到東西）
        if (all(shadowHit.hitUV != float2(-1, -1)))
            continue;
        
        // 計算 Phong Shading
        // Diffuse
        float3 Kd = GetKd(extraHitInfo);
        float NdotL = max(dot(extraHitInfo.hitInfo.normal, shadowRay.dir), 0);
        float3 diffuse = Kd * _LightColors[i] * NdotL;

        // Specular
        float3 R = reflect(-shadowRay.dir, extraHitInfo.hitInfo.normal); // 光 -> 物 反射
        float3 V = normalize(mul(_CameraToWorld, float4(0, 0, 0, 1)).xyz - extraHitInfo.hitInfo.position); // 物 -> 眼
        float spec = pow(max(dot(R, V), 0), 100);
        float3 specular = _MeshObjects[extraHitInfo.hitMesh].Ks.xyz * _LightColors[i] * spec;

        color += diffuse + specular;
    }

    return color;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Ray cameraRay = CreateCameraRay(id.x, id.y);
    ExtraHitInfo extraHitInfo = Trace(cameraRay, 1.#INF);
    Result[id.xy] = float4(Shade(extraHitInfo), 0.0);
}
